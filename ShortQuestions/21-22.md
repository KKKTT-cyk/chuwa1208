**21. What is the difference between first-level cache and second-level cache?**

| Feature                    | First-Level Cache (L1)                          | Second-Level Cache (L2)                                    |
| -------------------------- | ----------------------------------------------- | ---------------------------------------------------------- |
| **Scope**                  | Session / EntityManager level (local)           | SessionFactory level (global)                              |
| **Availability**           | Enabled by default (mandatory)                  | Disabled by default (optional)                             |
| **Sharing**                | Not shared between sessions                   | Shared across all sessions/users                         |
| **Life Span**              | Lives as long as the session                    | Lives until the application shuts down (or cache eviction) |
| **Configuration Required** | No                                              | Yes (cache provider + config)                              |
| **Cache Provider**         | Built-in (Hibernate/JPA)                        | External (Ehcache, Hazelcast, Infinispan, Redis, etc.)     |
| **Stores**                 | Managed entity instances                        | Entity data (and optionally collections)                   |
| **Transaction Awareness**  | Yes                                             | Depends on provider                                        |
| **Use Case**               | Avoid duplicate DB hits within the same session | Improve performance across sessions                        |
| **Eviction**               | When session is cleared/closed                  | Based on cache policy (LRU, TTL, etc.)                     |


**22. How do you understand @Transactional? (https://github.com/TAIsRich/tutorial-transaction)**

@Transactional is an annotation that ensures a series of database operations are executed within a transactional context.

- Rollback Mechanism: If an error occurs (like a RuntimeException or the "Wrong Request Body" scenario in the tutorial), Spring automatically triggers a rollback, undoing any changes made during that method call to maintain data integrity.

- Use Case: You use it in the Service Layer when a single business action involves multiple database steps (e.g., creating an Order AND processing a Payment). If one fails, the other should not be saved.