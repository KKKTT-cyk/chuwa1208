**3. How to create a new thread(Please also consider Thread Pool approach)?**

In Java, there are 4 practical ways to create and run work on a new thread.

1. Extend Thread (basic, rarely used in real projects)

```
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Running in: " + Thread.currentThread().getName());
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start(); // creates a new OS thread
    }
}


Pros / Cons

âœ… Simple
âŒ Bad design (tight coupling, canâ€™t extend another class, no reuse)
âŒ No return value, no pooling

ğŸ“Œ Use only for learning

```


2. Implement Runnable (classic & common)

```
Thread t = new Thread(() ->
    System.out.println("Running in: " + Thread.currentThread().getName())
);
t.start();

Pros / Cons

âœ… Better design than extending Thread
âŒ No return value
âŒ No built-in error handling or lifecycle control

ğŸ“Œ Good for simple concurrency
```

3. Callable + Future (return value + exception handling)

```
Callable<Integer> task = () -> {
    Thread.sleep(1000);
    return 42;
};

ExecutorService executor = Executors.newSingleThreadExecutor();
Future<Integer> future = executor.submit(task);

Integer result = future.get(); // blocks
System.out.println(result);

executor.shutdown();


Pros / Cons

âœ… Return values
âœ… Exception propagation
âŒ Still manual executor management

ğŸ“Œ Used heavily in real systems
```

4. Thread Pool (Production standard)

Creating threads is expensive. Thread pools:

Reuse threads

Control concurrency

Prevent resource exhaustion
    
- Fixed Thread Pool

```
ExecutorService pool = Executors.newFixedThreadPool(4);

for (int i = 0; i < 10; i++) {
    int taskId = i;
    pool.execute(() ->
        System.out.println("Task " + taskId + " on " + Thread.currentThread().getName())
    );
}

pool.shutdown();

ğŸ“Œ Use when

You know max parallelism

CPU-bound tasks

```

- Cached Thread Pool

```
ExecutorService pool = Executors.newCachedThreadPool();

ğŸ“Œ Use when

Short-lived async tasks

Bursty traffic
âš ï¸ Can create unbounded threads
```


- 4.3 Single Thread Executor

```
ExecutorService pool = Executors.newSingleThreadExecutor();

ğŸ“Œ Use when

Tasks must execute sequentially

Need thread safety without locks

```

- Scheduled Thread Pool

```
ExecutorService executor = new ThreadPoolExecutor(
    2,                // core threads
    4,                // max threads
    60, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>(100),
    Executors.defaultThreadFactory(),
    new ThreadPoolExecutor.AbortPolicy()
);

Use for

Cron jobs

Delayed tasks

Periodic cleanup
```

- Custom ThreadPoolExecutor

```
ExecutorService executor = new ThreadPoolExecutor(
    2,                // core threads
    4,                // max threads
    60, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>(100),
    Executors.defaultThreadFactory(),
    new ThreadPoolExecutor.AbortPolicy()
);

ğŸ“Œ Why this matters

Prevents OOM

Full control over queue & rejection strategy

Used in high-scale systems

```