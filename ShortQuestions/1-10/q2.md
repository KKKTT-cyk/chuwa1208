**2. Write a thread-safe singleton class**

Option 1. The recommendated approach (Bill Pugh Singleton)

```
public class Singleton {

    private Singleton();

    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}

The singleton instance is loaded only when getInstance() is called, making it lazy-loaded and thread-safe without requiring explicit synchronization.

```

Option 2. The Double-Checked Locking Approach

```
public class Singleton {

    private static volatile Singleton instance;

    private Singleton() {
        // private constructor prevents instantiation
    }

    public static Singleton getInstance() {
        if (instance == null) {                 // First check (no lock)
            synchronized (Singleton.class) {
                if (instance == null) {         // Second check (with lock)
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

```

'volatile' key word prevents instruction reordering, and guarantees visibility across threads.


Option 3. The Enum Singleton (Simplest & Safest)

```
public enum EnumSingleton {
    INSTANCE;

    public void someMethod() {
        // Perform actions here
    }
}
```

According to Joshua Bloch (author of Effective Java), a single-element enum type is the best way to implement a singleton. It provides 100% protection against serialization and reflection attacks "for free."

# Summary 

On a higher level, class initialization is synchronized by JVM.

More precisely:

- The JVM ensures only one thread initializes a class
- Other threads are blocked until initialization completes
- After completion, all threads see a fully initialized class

In option 1 and 3, we are leveraging this mechanism, where we shift synchronization from our code to JVM. That's why options 1 and 3 are stronger than synchronized.
