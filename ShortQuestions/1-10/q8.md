**8. Demonstrate deadlock and how to resolve it in Java code.**

Deadlock scenario: two threads acquire locks in different orders.

```
public class DeadLockDemo {
    private static final Object lock1 = new Object();
    private static final Object lock2 = new Object();

    public static void main(String[] args) {
        Runnable task1 = () -> {
            synchronized (lock1) {
                System.out.println("Thread 1: Holding lock1");
                sleep(100);

                synchronized (lock2) {
                    System.out.println("Thread 1: Holding lock2");
                }
            }
        };

        Runnable task2 = () -> {
            synchronized (lock2) {
                System.out.println("Thread 2: Holding lock2");
                sleep(100);

                synchronized (lock1) {
                    System.out.println("Thread 2: Holding lock1");
                }
            }
        };

        Thread t1 = new Thread(task1, "T1");
        Thread t2 = new Thread(task2, "T2");

        t1.start();
        t2.start();
    }

    private static void sleep(long ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

```

Deadlock happens because the lock order is inconsistent:

1. t1 acquires lock 1 and waits for lock 2, while t2 acquires lock 2 and waits for lock 1
2. now they both wait for the other to release the lock they need, hence the deadlock

So the most common solution is to ensure that all threads acquire locks in order. 

So the code above can be updated as follows:

```
public class DeadLockFixed {

    private static final Object lock1 = new Object();
    private static final Object lock2 = new Object();

    public static void main(String[] args) {

        Runnable task1 = () -> doWork("Thread 1");
        Runnable task2 = () -> doWork("Thread 2");

        new Thread(task1, "T1").start();
        new Thread(task2, "T2").start();
    }

    /**
     * Wraps locking logic in a consistent order to prevent deadlock
     */
    private static void doWork(String threadName) {
        // Always acquire lock1 first, then lock2
        synchronized (lock1) {
            System.out.println(threadName + ": Holding lock1");
            sleep(100);

            synchronized (lock2) {
                System.out.println(threadName + ": Holding lock2");
                // Critical section
            }
        }
    }

    private static void sleep(long ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

```

