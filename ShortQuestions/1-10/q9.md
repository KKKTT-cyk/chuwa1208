**9. How do threads communicate each other?**

1. Shared Memory / Shared Variables

The key idea is:

- Threads in the same process share the same memory space.

- One thread can write to a variable, and another thread can read it.

- Important: You must handle synchronization properly to avoid race conditions.

```
class SharedData {
    volatile int data;
}

public class ThreadCommunicationDemo {
    public static void main(String[] args) {
        SharedData shared = new SharedData();

        Runnable writer = () -> {
            shared.data = 100;
            System.out.println("Writer updated data to 100");
        };

        Runnable reader = () -> {
            System.out.println("Reader sees data: " + shared.data);
        };

        Thread t1 = new Thread(writer, "writer thread");
        Thread t2 = new Thread(reader, "reader thread");

        t1.start();
        t2.start();
    }
}

/*
This code does not guarantee the reader will read 100 each time, because volatile only guarantees visibility.
That means once the writer updates data, it will be directly in memory, therefore visible to all threads.
But there is a chance that reader accesses data first, before it is updated.
We should be mindful about this.
*/

```

2. wait() and notify() / notifyAll()

- Java provides methods for threads to communicate safely when waiting for a condition.

- These methods are called on shared objects, and the calling thread must hold the object's monitor (inside a synchronized block).

```
class SharedResource {
    int data;
    boolean available = false;

    public synchronized void produce(int value) throws InterruptedException {
        while (available) {
            wait(); // wait if data is not consumed
        }
        data = value;
        available = true;
        System.out.println("Produced: " + value);
        notify(); // notify consumer
    }

    public synchronized int consume() throws InterruptedException {
        while (!available) {
            wait(); // wait if no data
        }
        available = false;
        System.out.println("Consumed: " + data);
        notify(); // notify producer
        return data;
    }
}

public class ProducerConsumerDemo {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();

        Thread producer = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                try {
                    resource.produce(i);
                } catch (InterruptedException e) {
                }
            }
        });

        Thread consumer = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                try {
                    resource.consume();
                } catch (InterruptedException e) {
                }
            }
        });

        producer.start();
        consumer.start();
    }
}

But wait() and notify() should be avoided, because they

Are low-level

Are easy to misuse

Fail silently if done wrong

We should use BlockingQueue for producer-consumer pattern.

```

3. Higher-Level Concurrency Utilities

Java provides java.util.concurrent for more structured thread communication:

BlockingQueue â€“ Thread-safe queue for producer-consumer pattern.

```
BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(10);
queue.put(1);  // producer
int val = queue.take(); // consumer


So the code in 3 can be refactored as follows:


import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class ProducerConsumerBlockingQueue {

    public static void main(String[] args) {
        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(1);

        Thread producer = new Thread(() -> {
            try {
                for (int i = 0; i < 5; i++) {
                    queue.put(i); // blocks if queue is full
                    System.out.println("Produced: " + i);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        Thread consumer = new Thread(() -> {
            try {
                for (int i = 0; i < 5; i++) {
                    int value = queue.take(); // blocks if queue is empty
                    System.out.println("Consumed: " + value);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        producer.start();
        consumer.start();
    }
}


```


4. volatile

volatile ensures visibility: when one thread updates a variable, other threads immediately see the latest value.

```
class SharedFlag {
    volatile boolean flag = false;
}

SharedFlag sf = new SharedFlag();
sf.flag = true; // another thread will see this immediately

```

5. Interrupts

One thread can signal another thread using interrupt().

The interrupted thread can detect it using Thread.interrupted() or isInterrupted().