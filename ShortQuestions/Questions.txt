1. List all of the annotations you learned from class and homework to annotaitons.md
@Entity: 
Be used at the top of a class. This tells Hibernate it will be mapped to a database table

@Table: 
Set table name, add uniqueConstraints.

@Id:
Mark the primary key of the table.

@GeneratedValue(strategy = GenerationType.IDENTITY):
Defines how the id(primary key) is generated.
If use IDENTITY, Database will auto generate the id.

@Column(name = "XXX", nullable = false): 
Control the Column in Database:
name → column name in DB
nullable → NOT NULL constraint
unique → UNIQUE constraint
length → VARCHAR length
updatable → prevent updates
insertable → prevent inserts

@CreationTimestamp:
Automatically set the created time.

@UpdateTimestamp
Automatically set the updated time.


4. What is JPA? and what is Hibernate?
JPA: Java Persistence API, a standard set of rules and guidelines for java app.
Hibernate: Object-Relational Mapping framework for Java. It can map Java Classes to database tables.

5. What is Hiraki? what is the benefits of connection pool?
Hiraki: A high-performance JDBC connection pool for Java applications. 
In Spring Boot, it is a default connection pool.
Adv: Better Performance, requests are served immediately.


6. What is the @OneToMany, @ManyToOne, @ManyToMany ? write some examples.
@OneToMany: Represents a one-to-many relationship where one entity has multiple related entities.
Example:
@Entity
public class Department {
    @Id
    private Long id;
    @OneToMany(mappedBy = "department")
    private List<Employee> employees;
}

@ManyToOne: Represents a many-to-one relationship where multiple entities belong to one entity.
Example:
@Entity
public class Employee {
    @Id
    private Long id;
    @ManyToOne
    @JoinColumn(name = "department_id")
    private Department department;
}

@ManyToMany: Represents a many-to-many relationship where entities can have multiple relationships.
Example:
@Entity
public class Student {
    @Id
    private Long id;
    @ManyToMany
    @JoinTable(name = "student_course",
               joinColumns = @JoinColumn(name = "student_id"),
               inverseJoinColumns = @JoinColumn(name = "course_id"))
    private List<Course> courses;
}

@Entity
public class Course {
    @Id
    private Long id;
    @ManyToMany(mappedBy = "courses")
    private List<Student> students;
}


7. What is the cascade = CascadeType.ALL, orphanRemoval = true ? and what are the other CascadeType
and their features? In which situation we choose which one?
cascade = CascadeType.ALL: Automatically propagates all operations (PERSIST, MERGE, REMOVE, REFRESH, DETACH) from parent to child entities.
orphanRemoval = true: Automatically removes child entities when they are removed from the parent's collection.

Other CascadeType options:
- CascadeType.PERSIST: When parent is saved, children are also saved
- CascadeType.MERGE: When parent is merged, children are also merged
- CascadeType.REMOVE: When parent is deleted, children are also deleted
- CascadeType.REFRESH: When parent is refreshed, children are also refreshed
- CascadeType.DETACH: When parent is detached, children are also detached

When to use:
- CascadeType.ALL: Use when child entities have no independent existence (e.g., Order and OrderItems)
- CascadeType.PERSIST: Use when you want to save children automatically but not delete them
- CascadeType.REMOVE: Use when deleting parent should delete children
- orphanRemoval = true: Use when child entities should be deleted if removed from collection (e.g., removing an item from a list)

8. What is the fetch = FetchType.LAZY, fetch = FetchType.EAGER ? what is the difference? In which
situation you choose which one?
FetchType.LAZY: Related entities are loaded only when accessed (lazy loading). Uses proxy objects initially.
FetchType.EAGER: Related entities are loaded immediately with the parent entity (eager loading).

Differences:
- LAZY: Better performance, loads data on-demand, can cause LazyInitializationException if accessed outside transaction
- EAGER: Loads all data upfront, can cause N+1 query problem, uses more memory

When to use:
- LAZY: Default choice, use for most relationships, especially @OneToMany and @ManyToMany
- EAGER: Use when you always need the related data, for @ManyToOne and @OneToOne (usually safe)

9. What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list
some examples?
JPA naming convention: Spring Data JPA automatically generates query methods based on method names following specific patterns.
- findByFirstName(String firstName)
- findByFirstNameAndLastName(String firstName, String lastName)
- findByAgeGreaterThan(int age)
- findByEmailContaining(String email)
- findByDepartmentName(String name)
- findTop10ByOrderByCreatedDateDesc()
- findByStatusIn(List<String> statuses)

13. What is JPQL?
JPQL (Java Persistence Query Language): 
A platform-independent object-oriented query language similar to SQL, but operates on entity objects rather than database tables.


14. What is @NamedQuery and @NamedQueries?
@NamedQuery: Defines a reusable JPQL query that can be referenced by name in the code.
@NamedQueries: Container annotation for multiple @NamedQuery annotations.


15. What is @Query? In which Interface we write the sql or JPQL?
@Query: Annotation used to define custom queries (JPQL or native SQL) directly in repository interface methods.
We write @Query in the Repository interface (extends JpaRepository, CrudRepository, etc.).


16. What is HQL and Criteria Queries?
HQL (Hibernate Query Language): Hibernate's own query language, It uses Hibernate Session.
Criteria Queries: Type-safe, programmatic way to build queries using Criteria API. No string-based queries.


17. What is EnityManager?
EntityManager: Interface in JPA that manages entity lifecycle and provides methods for database operations.


18. What is SessionFactory and Session?
SessionFactory: Hibernate-specific interface that creates Session instances. It's thread-safe and should be created once per application.

Session: Hibernate-specific interface representing a single unit of work with the database. It's not thread-safe and should be used per thread/request.


19. What is Transaction? how to manage your transaction?
Transaction: A unit of work that groups multiple database operations into a single atomic operation. Either all operations succeed (commit) or all fail (rollback).

@Transactional
   public void placeOrder() {
    // We can save the quantity of the product to the database and increase the incoming to the database in this method
   }
   

20. What is hibernate Caching? Explain Hibernate caching mechanism in detail.
Hibernate Caching: Mechanism to store frequently accessed data in memory to reduce database queries and improve performance.

Types of Caching:
1. First-Level Cache (Session Cache):
   - Automatic, enabled by default
   - Per Session/EntityManager
   - Lifecycle tied to session
   - Stores entities within single transaction

2. Second-Level Cache:
   - Optional, needs configuration
   - Shared across sessions
   - Application-wide cache
   - Requires cache provider (EhCache, Infinispan, etc.)

3. Query Cache:
   - Caches query results
   - Works with second-level cache
   - Caches based on query and parameters

How it works:
- When entity is loaded, Hibernate checks cache first
- If found in cache (cache hit), returns from cache
- If not found (cache miss), queries database and stores in cache
- Cache eviction policies control when data is removed

21. What is the difference between first-level cache and second-level cache?
First-Level Cache:
- Scope: Per Session/EntityManager
- Lifecycle: Exists only during session lifetime
- Automatic: Enabled by default, no configuration needed
- Storage: In-memory within session
- Sharing: Not shared between sessions
- Use case: Optimizes queries within single transaction

Second-Level Cache:
- Scope: Application-wide, shared across all sessions
- Lifecycle: Persists beyond session lifetime
- Automatic: Requires explicit configuration and cache provider
- Storage: External cache (EhCache, Redis, etc.)
- Sharing: Shared by all sessions in application
- Use case: Caches frequently accessed, rarely changed data across transactions

Example:
Session 1 loads Employee(id=1) → stored in first-level cache → Session 1 can access without DB query
Session 2 loads Employee(id=1) → if second-level cache enabled, gets from there; otherwise queries DB

22. How do you understand @Transactional?
@Transactional: Spring annotation that declaratively manages transaction boundaries. It's a proxy-based AOP (Aspect-Oriented Programming) mechanism.