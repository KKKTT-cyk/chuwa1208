**1. Add newly learned annotations to your previous cheatsheet, add explainations for these annotations.**

Global error handling

Once an error is thrown (either by validation failing or a manual error), you need a way to catch it and send a clean JSON response to the user.

@ControllerAdvice

Think of this as a "Global Interceptor" for your application.

- A class marked with @ControllerAdvice will "listen" to all your Controllers.

- It allows you to centralize your error-handling logic in one place rather than having try-catch blocks inside every single API endpoint.

@ResponseStatus

If no Global Handler exists, Spring checks the Exception class for this annotation. 


@ExceptionHandler

This annotation is used inside your @ControllerAdvice class on specific methods.

- How it works: You tell the annotation which exception it should look for. For example, @ExceptionHandler(UserNotFoundException.class).

- When that specific error happens anywhere in your app, the annotated method will run, allowing you to return a custom error message and a specific HTTP status code (like 404 or 400).


Validation annotations

These are used on the fields of your DTOs (Data Transfer Objects) or Request bodies to define the rules that the data must follow.

- @NotEmpty: Ensures that the annotated field is not null and its length/size is greater than zero. It is commonly used for Strings or Collections to ensure they aren't just empty brackets or empty quotes.

- @Size(min=x, max=y): Validates that the length of a String or the size of a collection falls within the specified boundaries. For example, @Size(min=8) is a classic way to enforce password length.

Adding validation annotations to a class doesn't do anything by itself. You have to tell Spring to actually check them.

@Valid: You place this in your Controller method signature, usually right before the @RequestBody.


**3. Explain why do we need model mappers in Spring, and in what scanrios we need it.**

In Spring Boot, model mappers are libraries or components used to convert data from one object type to anotherâ€”most commonly between Entities (database models) and DTOs (Data Transfer Objects).

While you can technically do this manually using get and set methods, mappers automate the process, reducing boilerplate code and keeping your architecture clean.

Why do we need Model Mappers?

The primary reason we use mappers is to support the Separation of Concerns. In a well-structured Spring application, different layers should not share the same data models.

1. Security and Data Masking
Your database Entity might contain sensitive fields like password, is_admin, or internal internal_id. Returning the entity directly to a REST API would expose these. A mapper allows you to selectively copy only the "safe" fields to a DTO.

2. Preventing "Overposting" Attacks
If you accept an Entity directly as an input (e.g., in a @PostMapping), a malicious user could send a JSON payload containing an id or role field that they shouldn't be allowed to change. Mappers ensure you only process the fields defined in your DTO.

3. API Stability (Decoupling)
If you rename a column in your database, you don't want your API's JSON response to break for your mobile or web clients. A mapper acts as a buffer; you change the internal entity mapping, but the DTO (and thus the API contract) stays the same.

4. Reducing Boilerplate
Without a mapper, you might end up with "conversion fatigue":

```
// Manual mapping is tedious and error-prone
userDto.setFirstName(user.getFirstName());
userDto.setLastName(user.getLastName());
userDto.setEmail(user.getEmail());
// ... imagine 20 more fields
```

A mapper like ModelMapper or MapStruct handles this in a single line.

When do we need it? (Scenarios)

Scenario A: Flattening Nested Objects

If your Database Entity is deeply nested (e.g., Order -> Customer -> Address -> City), but your UI only needs a simple string like cityName, a mapper can "flatten" those objects into a single field in a DTO.

Scenario B: Versioning APIs

When you need to support two versions of an API (e.g., /v1/user and /v2/user), you can use one Entity but map it to two different DTOs. This avoids duplicating your database logic.

Scenario C: Calculated Fields

Sometimes a DTO needs a field that doesn't exist in the database, such as fullName (a combination of firstName and lastName). Mappers can be configured to perform this logic during the transformation.


**4. Provide 3 examples in which model mapper will NOT map succesfully, explain why.**

Here are three common scenarios where a model mapper (like ModelMapper or MapStruct) will fail without manual configuration.

1. Incompatible Property Names

Mappers typically use a "Standard Matching Strategy," which looks for identical field names. If the source and destination names do not match exactly, the mapper will simply skip the field.

The Scenario:

Source (Entity): private String accountStatus;

Destination (DTO): private String status;

Why it fails: The mapper cannot "guess" that accountStatus should go into status. It treats them as two completely unrelated properties.


2. Deep Nesting with Ambiguous Naming

Mappers often try to "flatten" objects (e.g., user.address.city -> userCity). However, if the naming is ambiguous or deep, the automatic engine gets lost.

The Scenario:

Source (Entity): Order has a Customer, and Customer has a String name.

Destination (DTO): OrderDTO has a field called clientIdentity.

Why it fails: The mapper's intelligent mapping engine looks for customerName or name. Because the DTO uses clientIdentity, the connection is broken. The mapper doesn't know that "Client" and "Customer" are synonyms in your business logic.

3. Differing Data Types (Type Mismatch)

Mappers are great at converting int to long or String to String, but they fail when the logic requires a transformation rather than just a copy.

The Scenario: * Source (Entity): private List<String> roles; (A list of strings like "ADMIN", "USER").

Destination (DTO): private String roles; (A single comma-separated string like "ADMIN, USER").

Why it fails: The mapper sees a List and a String. It doesn't know how you want to join that list. Should it take the first element? Should it comma-separate them?

How to fix these failures?
In all three cases, you must provide a Custom Mapping Configuration:

In ModelMapper: You use a PropertyMap to explicitly define the link: map().setStatus(source.getAccountStatus()).

In MapStruct: You use the @Mapping annotation: @Mapping(source = "accountStatus", target = "status").


**Explain how model mapper cast different data types between source object and target class.**

ModelMapper performs "casting" through a process of intelligent conversion rather than a simple Java type cast.

- Primitive-to-Primitive: It uses built-in logic to handle standard Java widening/narrowing (e.g., int to Long).

- Object-to-String: It calls .toString() on source objects to populate destination String fields automatically.

- The Conversion Engine: It maintains a registry of Converters. When it encounters a mismatch (e.g., String to LocalDate), it looks for a registered converter that matches those specific types.

- Recursive Mapping: If types are complex objects (e.g., Address to AddressDTO), it triggers a new mapping cycle for those sub-objects rather than trying to cast the reference.