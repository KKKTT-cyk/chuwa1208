**11. (Optional) Check out a new branch(https://github.com/TAIsRich/springboot-redbook/tree/hw02_01_jdbc T emplate) from branch 02_post_RUD, replace the dao layer using JdbcTemplate.**


**12. type the code, you need to checkout new branch from branch 02_post_RUD, name the new branch with https://github.com/TAIsRich/springboot-redbook/tree/hw05_01_slides_JPQL.**



**13. What is JPQL?**

JPQL (Java Persistence Query Language) is a platform-independent object-oriented query language defined as part of the Jakarta Persistence (JPA) specification.

- Object-Oriented: Unlike SQL, which queries tables and columns, JPQL queries entities (Java classes) and their attributes (fields).

- Database Independent: JPQL is translated by the persistence provider (like Hibernate) into the specific SQL dialect of the underlying database.

- Example: SELECT e FROM Employee e WHERE e.salary > 50000 (Here, Employee is a Java class, not a table).


**14. What is @NamedQuery and @NamedQueries?**

These annotations are used to define static, reusable queries at the Entity level.

- @NamedQuery: Defines a single query with a unique name. These queries are compiled once when the application starts, which improves performance and helps catch syntax errors early.

- @NamedQueries: A container annotation used to group multiple @NamedQuery annotations on a single entity.

@Entity
@NamedQueries({
    @NamedQuery(name="User.findByEmail", query="SELECT u FROM User u WHERE u.email = :email"),
    @NamedQuery(name="User.findAll", query="SELECT u FROM User u")
})
public class User { ... }


**15. What is @Query? In which Interface we write the sql or JPQL?**

@Query is a Spring Data JPA annotation used to declare queries directly on Repository interface methods.

- Flexibility: It allows you to write both JPQL (default) and Native SQL (by setting nativeQuery = true).

- Interface: You write these in interfaces that extend JpaRepository or CrudRepository

```
public interface UserRepository extends JpaRepository<User, Long> {
    @Query("SELECT u FROM User u WHERE u.status = ?1") // JPQL
    List<User> findByStatus(String status);
}
```

**16. What is HQL and Criteria Queries?**

- HQL (Hibernate Query Language): Hibernate’s predecessor to JPQL. It is almost identical to JPQL but includes more features (like INSERT INTO ... SELECT). JPQL is a subset of HQL.

- Criteria Queries: A programmatic, type-safe way to build queries using Java objects. It is useful for dynamic queries (where search criteria are only known at runtime) because it avoids string concatenation and provides compile-time checking.

**17. What is EnityManager?**

The EntityManager is the primary interface in JPA used to interact with the persistence context. It manages the lifecycle of entities (Create, Read, Update, Delete).

Key methods: persist() (save), merge() (update), remove() (delete), and find() (lookup).

**18. What is SessionFactory and Session?**

- SessionFactory: A thread-safe, heavyweight object that holds configuration for the entire application. It is used to create Session objects. Usually, there is one SessionFactory per database.

- Session: A lightweight, non-thread-safe object that represents a single "unit of work" or connection to the database. It is Hibernate’s version of the EntityManager.


**19. What is Transaction? how to manage your transaction?**

A Transaction is a sequence of database operations that are treated as a single unit. It follows ACID properties (Atomicity, Consistency, Isolation, Durability).

Management:

- Programmatic: Manually using tx.begin(), tx.commit(), and tx.rollback() code.

- Declarative (Recommended): Using the @Transactional annotation in Spring, which handles the start, commit, or rollback automatically based on whether the method succeeds or throws an exception.


**20. What is hibernate Caching? Explain Hibernate caching mechanism in detail.**

- First-Level Cache (L1): Associated with the Session/EntityManager. It is mandatory. Every object loaded in a session is stored here. It lasts only for the duration of the session.

- Second-Level Cache (L2): Associated with the SessionFactory. It is optional and shared across all sessions. If an entity is not found in L1, Hibernate looks in L2 before hitting the database. (Common providers: Ehcache, Hazelcast).

- Query Cache: Stores the results of specific queries (the IDs of the returned entities).

