1. List all of the annotations you learned from this class session.

@Controller — traditional MVC controller

@Controller is used for server-side rendered views (MVC).

It returns views (HTML, JSP, Thymeleaf, etc.)

Methods typically return:

- String (view name)

- ModelAndView

Data is passed to the view via Model

```
@Controller
@RequestMapping("/users")
public class UserController {

    @GetMapping("/profile")
    public String profile(Model model) {
        model.addAttribute("name", "Alice");
        return "profile"; // resolves to profile.html
    }
}

```

What happens internally

- Method returns "profile"

- Spring treats it as a view name

- ViewResolver finds profile.html

- HTML is rendered and sent to browser

But if you return object, it doesn't work unless you add @ResponseBody


@RestController — REST API controller

It combines @Controller and @ResponseBody and returns an object.

```
@RestController
@RequestMapping("/api/users")
public class UserRestController {

    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return new User("Alice");
    }
}

```


2. Explain tight coupling vs loose coupling and what does Spring IOC do?

Tight Coupling — A class creates and depends directly on a concrete implementation.

Example:

```
class EmailService {
    public void sendEmail(String msg) {
        System.out.println("Sending email: " + msg);
    }
}

class UserService {
    private EmailService emailService = new EmailService();

    public void notifyUser() {
        emailService.sendEmail("Hello");
    }
}

```

Why this is bad

- UserService knows the exact class EmailService

- You cannot easily replace EmailService (e.g., SMS, Push)

- Hard to test (you can’t mock it)

- Any change → modify UserService


Loose Coupling — A class depends on an interface, not a concrete implementation. The dependency is provided from outside.

Example

```
// Create an interface

interface NotificationService {
    void send(String msg);
}

// Two different concrete implementations

class EmailService implements NotificationService {
    public void send(String msg) {
        System.out.println("Email: " + msg);
    }
}

class SmsService implements NotificationService {
    public void send(String msg) {
        System.out.println("SMS: " + msg);
    }
}

// Inject from outside

class UserService {
    private final NotificationService notificationService;

    public UserService(NotificationService notificationService) {
        this.notificationService = notificationService;
    }

    public void notifyUser() {
        notificationService.send("Hello");
    }
}

Why this is good

- Easily swap implementations

- Easy to test (mock interface)

- Follows SOLID principles

- No code changes when behavior changes

```

Spring IoC manages the life cycles of objects for us. You don't do "new UserService()" anymore. Spring takes over and provides objects when you need them. You only need to declare them.

Spring:

- Creates objects (beans)

- Manages their lifecycle

- Injects dependencies