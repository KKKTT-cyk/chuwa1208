**12. Explain different types of application context in Spring framework, with screenshots.**

1. AnnotationConfigApplicationContext

This is the modern standard for standalone Java applications. It accepts classes annotated with @Configuration and @Component to define beans.

Best for: Pure Java-based configuration without any XML.

Usage: Used heavily in modern microservices and Spring Boot-like setups.


2. ClassPathXmlApplicationContext

This implementation loads the context definition from an XML file located in your project's classpath.

Best for: Legacy projects or environments where configuration needs to be externalized in XML files.

Note: It looks for the file in the src/main/resources folder by default.

3. FileSystemXmlApplicationContext
Similar to the ClassPath version, but it loads the XML file from a specific path in the file system (e.g., C:/config/beans.xml).

Best for: Situations where the configuration file is not bundled within the application's JAR/WAR file.

**13. Compare @Component and @Bean and in which scenario they should be used.**

1. @Component: The "Automatic" Way

When you annotate a class with @Component, Spring detects it during a component scan and automatically creates an instance of it. This is the "standard" way to build your own application layers.

Stereotypes: You’ll often use specialized versions like @Service, @Repository, or @RestController.

Pros: Minimal boilerplate; just add the annotation and you're done.

Cons: You can't use it on classes you didn't write (like a library) because you can't modify the source code.

```
@Component
public class PaymentProcessor {
    public void process() {
        // Logic here
    }
}
```

2. @Bean: The "Manual" Way

@Bean is used inside a class annotated with @Configuration. You write a method that returns an object, and Spring takes that returned object and manages it as a bean.

Pros: You have total control. You can add logic (like if/else or try/catch) before returning the object.

Cons: Requires more code and a separate configuration class.

```
@Configuration
public class AppConfig {
    
    @Bean
    public ExternalLibraryService externalService() {
        // You can configure the object exactly how you want it
        ExternalLibraryService service = new ExternalLibraryService();
        service.setApiKey("12345-ABC");
        return service;
    }
}
```

Use @Component when...

- You are writing new code for your application (Services, Controllers, DAOs).

- The class doesn't require complex initialization logic.

- You want to keep your configuration clean and rely on "Convention over Configuration."

Use @Bean when...

- You are integrating a third-party library (e.g., creating a RestTemplate, ObjectMapper, or DataSource). You can't put @Component on their source code.

- The bean creation requires complex logic or custom configuration.

- You need to create multiple instances of the same class with different configurations.

- You want to decouple the bean definition from the bean implementation.


**14. Explain Spring bean scopes and how to pick the correct bean scope.**


In Spring, a bean scope defines the lifecycle and visibility of a bean—that is, how many instances of a bean Spring creates and how long it lives.

Stateless service (no stored data per user/request)
→ singleton (default).
Example: @Service class EmailSender

Stateful bean or needs fresh copy each use
→ prototype.
Example: @Component class UserForm

Web request-specific data
→ request.
Example: @Component @Scope("request") class RequestTracker

Session-specific data
→ session.
Example: @Component @Scope("session") class ShoppingCart

Application-wide data (shared across requests)
→ application.

WebSocket-specific session
→ websocket.