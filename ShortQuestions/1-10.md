**1. List all of the annotations you learned from class and homework to annotaitons**

We learned many Spring JPA annotations, including:

- @RestController: Marks the class as a web controller where every method returns a domain object instead of a view.

- @RequestMapping("/path"): Sets the base URL path for the controller.

- @Entity: Specifies that the class is a mapped entity to a database table.

- @Id & @GeneratedValue: Defines the primary key and its generation strategy.

- @Column: Customizes the column mapping (name, nullable, length).

- @Service: Marks a class as a service layer component for business logic.

- @Repository: Marks the data access layer.

- @Autowired: Injects dependencies (though Constructor Injection is preferred).

- @PathVariable: Extracts values from the URI template.

- @RequestBody: Maps the HttpRequest body to a transfer object (DTO/Entity).


**2. Type out the code for the Comment feature of the class project.**

Class Comment

Entity

```
@Entity
public class Comment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String content;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "post_id")
    private Post post;
    
    // Getters and Setters
}
```

Repository

```
@Repository
public interface CommentRepository extends JpaRepository<Comment, Long> {
    List<Comment> findByPostId(Long postId);
}
```

**3. In postman, call all of the APIs in PostController and CommentController.**



**4. What is JPA? and what is Hibernate?**

JPA (Java Persistence API): It is a specification (a set of rules and interfaces). It tells you how to do ORM (Object-Relational Mapping) but doesn't do the work itself.

Hibernate: This is the implementation. It is the actual engine that translates your Java code into SQL queries. Think of JPA as a "Rulebook" and Hibernate as the "Player."


**5. What is Hiraki? what is the benefits of connection pool?**

HikariCP is the default JDBC connection pool in Spring Boot. It is known for being extremely fast and lightweight.

Benefits of a Connection Pool:

- Performance: Opening a new database connection for every request is expensive and slow.

- Resource Management: It reuses existing connections.

- Throttling: It prevents the application from overwhelming the database by limiting the number of active connections.


**6. What is the @OneToMany, @ManyToOne, @ManyToMany? write some examples.**

- @OneToMany: One user has many posts.

- @ManyToOne: Many comments belong to one post.

- @ManyToMany: Many students belong to many courses (requires a Join Table).


```
@OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Post> posts = new ArrayList<>();

@ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id") // The foreign key column in the DB
    private User user;

@ManyToOne
    @JoinColumn(name = "post_id", nullable = false)
    private Post post;    
```

**7. What is the cascade = CascadeType.ALL, orphanRemoval = true? and what are the other Cascade Type and their features? In which situation we choose which one?**

Cascading & Orphan Removal

- CascadeType.ALL: Any action performed on the parent (save, delete, update) is automatically passed to the children.

- orphanRemoval = true: If a child is removed from the parent's list (e.g., post.getComments().remove(comment)), that child is automatically deleted from the database.

Other Types:

- PERSIST: Only pass "save" actions.

- REMOVE: Only pass "delete" actions.

- MERGE: Only pass "update" actions.


**8. What is the fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the difference? In which situation you choose which one?**

- FetchType.LAZY: The data is not loaded from the DB until you specifically call the getter (e.g., post.getComments()). Best for performance.

- FetchType.EAGER: The data is loaded immediately with the parent.

**9. What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?**

JPA can generate SQL queries based on the method name in your Repository. You do not need to implement the method; Spring Data JPA does it for you.

Examples:

- findByTitle(String title) -> SELECT * FROM posts WHERE title = ?

- findByTitleContaining(String keyword) -> Uses LIKE %keyword%

- findAllByOrderByCreatedAtDesc() -> Adds ORDER BY clause.

- countByStatus(String status) -> Returns a count.


**10. Try to use JPA advanced methods in your class project. In the repository layer, you need to use the naming convention to use the method provided by JPA.**

This could be an example of advanced JPA method.

```
// Find all comments for a specific post, ordered by newest first
List<Comment> findAllByPostIdOrderByCreatedDateDesc(Long postId);
```