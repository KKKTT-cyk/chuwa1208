**20. What kind of locks do you know? What is the advantage of each lock?**

In Java (and OS concepts in general), locks are mechanisms to control concurrent access to shared resources. Different locks exist because no single lock is optimal for all scenarios.

1. Intrinsic Lock (Monitor Lock / synchronized)

Provided by: JVM
Keyword: synchronized

```
synchronized (obj) {
    // critical section
}
```

Advantages

✔ Simple and easy to use
✔ Automatic lock release (even on exception)
✔ Reentrant (same thread can re-acquire)
✔ JVM optimizations (biased lock, lightweight lock)

Disadvantages

✖ No try-lock
✖ No timeout
✖ No fairness
✖ Can block forever

Use when

- Simple mutual exclusion

- Low contention

- Readability matters

2. Explicit Lock (Lock interface – ReentrantLock)

```
Package: java.util.concurrent.locks

Lock lock = new ReentrantLock();
lock.lock();
try {
    // critical section
} finally {
    lock.unlock();
}
```

Advantages

✔ tryLock() (non-blocking)
✔ lockInterruptibly()
✔ Timeout support
✔ Optional fairness
✔ Multiple Condition objects

Disadvantages

✖ Must manually unlock
✖ More verbose
✖ Misuse can cause deadlock

Use when

- Need timeout or interruptible locking

- Complex coordination logic

- Fine-grained control

3. Read–Write Lock (ReadWriteLock / ReentrantReadWriteLock)

```
ReadWriteLock rw = new ReentrantReadWriteLock();
rw.readLock().lock();
rw.writeLock().lock();
```

Advantages

✔ Multiple readers allowed
✔ Writer gets exclusive access
✔ Higher throughput for read-heavy workloads

Disadvantages

✖ Writer starvation possible
✖ More complex

Use when

- Read-heavy systems (caches, configs)

- Reads >> Writes

4. Stamped Lock (StampedLock)
```
StampedLock lock = new StampedLock();
long stamp = lock.writeLock();
lock.unlockWrite(stamp);
```

Advantages

✔ Supports optimistic reads
✔ Faster than ReadWriteLock
✔ No starvation

Disadvantages

✖ Not reentrant
✖ Complex API

Use when

- Read-heavy + high concurrency

- Performance-sensitive systems

