**18. What is Atomic classes? How many types of Atomic classes? Give me some code example of Atomic classes and its main methods. when to use it?**

Atomic classes are part of the java.util.concurrent.atomic package. They provide a way to perform thread-safe operations on single variables without using synchronized.

Key points:

- They ensure atomicity – operations are performed as a single, indivisible step.

- They are lock-free and faster than synchronized for simple operations.

- Mainly used for counters, flags, references, etc. in multi-threaded programs.


1. Thread-safe Counter
```
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicIntegerDemo {

    static AtomicInteger counter = new AtomicInteger(0);

    public static void main(String[] args) throws InterruptedException {

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter.incrementAndGet(); // atomic
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println(counter.get()); // 2000
    }
}

```

2. AtomicBoolean – When You Need a Flag

```
import java.util.concurrent.atomic.AtomicBoolean;

public class AtomicBooleanDemo {

    static AtomicBoolean started = new AtomicBoolean(false);

    public static void main(String[] args) {

        if (started.compareAndSet(false, true)) {
            System.out.println("Started successfully");
        } else {
            System.out.println("Already started");
        }
    }
}

```

3. Atomic Object Replacement

```
import java.util.concurrent.atomic.AtomicReference;

class Config {
    final String value;
    Config(String value) { this.value = value; }
}

public class AtomicReferenceDemo {

    static AtomicReference<Config> config =
            new AtomicReference<>(new Config("v1"));

    public static void main(String[] args) {

        config.compareAndSet(
                config.get(),
                new Config("v2")
        );

        System.out.println(config.get().value); // v2
    }
}

```

4. AtomicIntegerArray – Atomic Array Elements

```
import java.util.concurrent.atomic.AtomicIntegerArray;

public class AtomicArrayDemo {

    static AtomicIntegerArray array = new AtomicIntegerArray(3);

    public static void main(String[] args) {
        array.incrementAndGet(0);
        array.addAndGet(1, 5);

        System.out.println(array.get(0)); // 1
        System.out.println(array.get(1)); // 5
    }
}

```

Use Atomic when:

- Low to Medium Contention: Most of the time, the CAS will succeed on the first or second try.

- Single Variable: You only need to update one thing (a counter, a boolean flag, or a single object reference).

- Non-Blocking is required: You want to ensure that one stalled thread (e.g., one that gets paused by the Garbage Collector) doesn't stop every other thread from making progress.

Use synchronized when:

- High Contention: If 100 threads are constantly trying to increment the same counter, the "spin-loop" in an AtomicInteger becomes a "busy-wait" that eats up 100% of your CPU without doing useful work. In this case, letting the threads "sleep" (synchronized) is actually more efficient.

- Multiple Variables: If you need to update two variables together (e.g., accountA.withdraw(10) and accountB.deposit(10)), an Atomic class cannot help you. You need a lock to make the entire block atomic.

- Complex Logic: If the update involves a database call or a long calculation, you don't want a thread "spinning" and wasting CPU while waiting for those slow operations to finish.