## **1. Add newly learned annotations to your previous cheatsheet, and add explanations for these annotations.**
[Annotations update](annotations.md)
---

## **2. Walkthrough sample codes under the following commit, and run the application locally:**
https://github.com/CTYue/springboot-redbook/commits/06_mapper-exception

---

## **3. Explain why we need Model Mapper in Spring, and in what scenarios it is needed.**
- In Spring applications, Model Mapper is used to simplify and standardize the conversion between different object models, most commonly between Entity objects and DTO (Data Transfer Object) classes.
- Why need? 
- - In a typical layered Spring architecture (Controller → Service → Repository), different layers serve different responsibilities: Entity objects represent database tables and persistence logic. DTO objects represent API request and response payloads.
- - Model Mapper helps by: Automatically mapping fields between objects with similar structures. Reducing repetitive and error-prone manual mapping code. Improving code readability and maintainability.
- When is needed?
- - Entity ↔ DTO conversion: Mapping database entities to response DTOs, and request DTOs to entities.
- - Layer separation: Enforcing clean separation between persistence layer and API layer.
- - Large or evolving models: When objects contain many fields and manual mapping becomes difficult to maintain.
- - Consistent mapping logic: Centralizing object conversion rules instead of duplicating logic across services.

---

## **4. Provide 3 examples in which Model Mapper will NOT map successfully, and explain why.**
- Example 1: Different Field Names
```java
class UserEntity {
    private String firstName;
    private String lastName;
}

class UserDTO {
    private String givenName;
    private String familyName;
}

```
- Example 2: Incompatible Data Types
```java
class OrderEntity {
    private Long orderId;
    private Date createdAt;
}

class OrderDTO {
    private String orderId;
    private String createdAt;
}

```
- Example 3: Nested or Complex Object Structures
```java
class PostEntity {
    private UserEntity author;
}

class UserEntity {
    private String username;
}

class PostDTO {
    private String authorName;
}
```
---

## **5. Explain how Model Mapper casts different data types between source objects and target classes.**
- Model Mapper casts different data types by using a converter-based mechanism during the mapping process. It automatically converts compatible types (such as primitive types, wrapper classes, and simple numeric conversions) using built-in converters. For simple cases, values may be converted to String using toString().
- When data types are incompatible or complex (such as Date to String or nested objects), Model Mapper requires custom converters or explicit mappings to define how values should be transformed. This approach allows Model Mapper to handle both simple and complex type conversions in a flexible and controlled way.
---

## **6. Add your own API exceptions so that when something goes wrong in the service layer, your REST API returns a customized response and HTTP status code.**
- 
---

## **7. Explain how Controller Advice works.**
Is there any other approach to achieve the same or similar global API exception handling?
- @ControllerAdvice is a Spring mechanism for cross-cutting concerns across multiple controllers. For REST APIs, we usually use @RestControllerAdvice (equivalent to @ControllerAdvice + @ResponseBody) to return JSON responses.
- Local @ExceptionHandler inside each Controller
- Implement HandlerExceptionResolver
- Extend ResponseEntityExceptionHandler
- Use @ResponseStatus on custom exceptions
- Spring Boot default /error handling (BasicErrorController)
---

## **8. Explain the difference between throwing a regular exception and a customized API exception that is eventually handled by Controller Advice.**
Please provide screenshots to explain your findings.
- Regular Exception
- - Represents unexpected system or runtime errors
- - Commonly defaults to HTTP 500 Internal Server Error
- - Provides limited control over HTTP status codes
- - Error responses are often generic and inconsistent
- - Does not clearly distinguish business errors from system failures
- - Less suitable for client-side error handling
- Customized API Exception
- - Represents expected business-level errors (e.g., not found, validation failure)
- - Explicitly defines the HTTP status code (e.g., 404, 400)
- - Handled centrally by @ControllerAdvice
- - Returns a structured and consistent API error response
- - Improves API clarity and maintainability
- - Enables clients to reliably interpret and handle errors

---

## **9. Write regular expressions to restrict the value of attributes for Post or Comment.**
You may use https://regex101.com/ to construct, test, and validate your regular expressions.
#### comment email
```java
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Pattern;

public class CommentDto {

  @NotBlank(message = "Email should not be null or empty")
  @Pattern(
      regexp = "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$",
      message = "Email must be a valid format, e.g., name@example.com"
  )
  private String email;
}
```
####  Comment name
```java
@NotBlank(message = "Name should not be null or empty")
@Pattern(
    regexp = "^[A-Za-z][A-Za-z\\s'-]{1,39}$",
    message = "Name must be 2-40 chars and contain only letters/spaces/'/-"
)
private String name;
```

#### Comment body
```java
@NotBlank(message = "Body should not be null or empty")
@Pattern(
    regexp = "^(?=.{1,500}$)(?!\\s*$).+$",
    message = "Body must be 1-500 chars and cannot be whitespace only"
)
private String body;
```
---

## **10. Explain Spring Framework fundamental principles.**
### How do these principles help in building scalable and maintainable business applications?
- **Inversion of Control (IoC)**  
  Spring manages object creation and lifecycle, reducing tight coupling between components.
- **Dependency Injection (DI)**  
  Dependencies are injected rather than created manually, making code easier to test, extend, and maintain.
- **Aspect-Oriented Programming (AOP)**  
  Cross-cutting concerns (logging, transactions, security) are separated from business logic, keeping core code clean.
- **Separation of Concerns (SoC)**  
  Clear layering (Controller, Service, Repository) improves readability, scalability, and parallel development.
- **Loose Coupling & Modularity**  
  Components depend on abstractions, allowing implementations to change with minimal impact.
**Why this matters:**  
These principles enable scalable, maintainable business applications by improving code clarity, flexibility, testability, and long-term evolution.

---

## **11. Explain different types of Dependency Injection in Spring.**
Describe their suitable use cases, and explain why field injection is generally not recommended.  
Please provide necessary code snippets and screenshots if possible.
#### 1) Constructor Injection
**How it works:** Dependencies are provided through the class constructor.
```java
@Service
public class PostService {
    private final PostRepository postRepository;

    public PostService(PostRepository postRepository) {
        this.postRepository = postRepository;
    }
}
```
#### 2) Setter Injection
**How it works:** Dependencies are injected through setter methods.
```java
@Service
public class PostService {
    private PostRepository postRepository;

    @Autowired
    public void setPostRepository(PostRepository postRepository) {
        this.postRepository = postRepository;
    }
}
```
#### 3) Field Injection
**How it works:** Spring injects dependencies directly into fields.
- Not recommend
- Why it’s generally not recommended
- - Harder to unit test (requires Spring context or reflection)
- - Breaks immutability (field cannot be final)
- - Hides required dependencies (not obvious from constructor signature)
- - Can lead to circular dependency issues being harder to detect early
- - Tighter coupling to Spring framework (less plain Java)
- - Prefer constructor injection for most cases.

#### Method/Parameter Injection
**How it works:** Spring injects dependencies into a method parameter, often in @Bean methods.
```java
@Configuration
public class AppConfig {
    @Bean
    public ModelMapper modelMapper() {
        return new ModelMapper();
    }

    @Bean
    public PostService postService(PostRepository repo) {
        return new PostService(repo);
    }
}
```
---

## **12. Explain different types of ApplicationContext in the Spring Framework.**
Provide screenshots if possible.  
You may refer to: https://github.com/CTYue/springIOC

---

## **13. Compare @Component and @Bean, and explain in which scenarios each should be used.**
- Use @Component when:
- - You control the class source code
- - You want Spring to auto-detect it
- - It’s a standard layer bean (service/repo/controller)
- Use @Bean when:
- - The class is from a third-party library (e.g., ModelMapper, ObjectMapper)
- - You need custom initialization/configuration
- - You need multiple beans of the same type with different settings
---

## **14. Explain Spring Bean scopes and how to pick the correct bean scope.**
- A Spring bean scope defines how long a bean lives and how many instances of that bean are created within the Spring container.
#### Bean scopes:
#### Singleton (Default)
- One instance per Spring container
- Shared across the entire application
- Created at application startup (eager by default)
- - Use when:
- Bean is stateless
- Used across multiple requests
- Typical for services, repositories, utilities
#### Prototype
- New instance every time it is requested
- Not managed after creation (Spring does not handle destruction)
- - Use when:
- Bean is stateful
- Each use requires a fresh instance
#### Request (Web applications only)
- One instance per HTTP request
- Automatically destroyed after request completes
- - Use when
- Bean holds request-specific data (e.g., request metadata)
#### Application
- One instance per ServletContext
- Shared across the entire web application
- - Use when:
- Bean holds application-wide shared state
---

## **15. Explain the difference between Bean ID and Bean Class.**
#### Bean ID
- The Bean ID (also called bean name) is the unique identifier of a bean inside the Spring container.
- It represents how the bean is referenced.
#### Bean Class
- The Bean Class is the Java class that defines:
- - The bean’s structure
- - Its fields, methods, and behavior
- It represents what the bean is (its type).
- Spring uses the bean class to:
- - Instantiate the object
- - Perform dependency injection by type
- - Used when injecting beans by name.
---

## **16. When a bean has multiple alternative implementations, how does Spring decide which implementation to inject/autowire?**
- Spring uses a resolution priority order to determine which implementation to inject. If Spring cannot uniquely resolve the dependency, it throws an exception.
#### By Type (Default Behavior)
- Spring first tries to autowire by type.
#### Using @Primary
- @Primary marks one implementation as the default choice.
#### Using @Qualifier (Recommended for Clarity)
- @Qualifier explicitly specifies which bean to inject by Bean ID.
#### By Bean Name Matching the Field Name
- If field name matches a bean ID, Spring may use it as a fallback.
#### Using @Profile (Environment-Based Selection)
- Different implementations can be activated based on environment.
#### Using Conditional Annotations
- Spring supports conditional loading using @Conditional.