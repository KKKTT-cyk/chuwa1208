### 1. List all of the annotations you learned from class and homework to annotaitons.md
- [Annotations Summary](annotations.md)
### 2. Type out the code for the Comment feature of the class project.
Entity
```
@Entity
public class Comment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String content;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "post_id")
    private Post post;
    
    // Getters and Setters
}
```
Repository

```
@Repository
public interface CommentRepository extends JpaRepository<Comment, Long> {
    List<Comment> findByPostId(Long postId);
}
```
### 3. In postman, call all of the APIs in PostController and CommentController.
### 4. What is JPA? and what is Hibernate?
- JPA is a standard of Object Relational Mapping. It is an annotations for creating the object relational mapping.
- Hibernate is a Java ORM (Object-Relational Mapping) framework that lets you work with a relational database using Java objects instead of raw SQL.
### 5. What is Hiraki? what is the benefits of connection pool?
- HikariCP efficiently manages and reuses JDBC connections to improve performance and scalability.
- Benefits of CP: Improves performance, scalability, and resource management by reusing database connections.
### 6. What is the @OneToMany, @ManyToOne, @ManyToMany? write some examples.
- @OneToMany: One object relates to many others
```java
//One User → Many Orders
@Entity
public class User {

    @Id
    @GeneratedValue
    private Long id;

    @OneToMany(mappedBy = "user")
    private List<Order> orders;
}
@Entity
public class Order {

    @Id
    @GeneratedValue
    private Long id;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
}

```
- @ManyToOne: Many objects relate to one
```java
//Many Orders → One User
@Entity
public class Order {

    @Id
    @GeneratedValue
    private Long id;

    @ManyToOne
    @JoinColumn(name = "user_id") // foreign key
    private User user;
}
@Entity
public class User {

    @Id
    @GeneratedValue
    private Long id;
}

```
- @ManyToMany: Many objects relate to many
```java
//Students ↔ Courses
@Entity
public class Student {

    @Id
    @GeneratedValue
    private Long id;

    @ManyToMany
    @JoinTable(
        name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    private List<Course> courses;
}
@Entity
public class Course {

    @Id
    @GeneratedValue
    private Long id;

    @ManyToMany(mappedBy = "courses")
    private List<Student> students;
}
```

### 7. What is the cascade = CascadeType.ALL, orphanRemoval = true? and what are the other CascadeType and their features? In which situation we choose which one?
- cascade = CascadeType.ALL means all entity operations performed on the parent entity will be automatically propagated to its child entities.
- orphanRemoval = true means when a child entity is removed from the parent’s collection, it will be deleted from the database.
- Other CascadeType includes:
- - PERSIST: when the parent entity is saved, its child entities are automatically saved as well.
- - MERGE: when the parent entity is updated, its child entities are also updated automatically.
- - REMOVE: when the parent entity is deleted, its child entities are also deleted.
- - REFRESH: when the parent entity is refreshed from the database, the child entities are refreshed as well.
- - DETACH: when the parent entity is detached from the persistence context, its child entities are detached as well.
### 8. What is the fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the difference? In which situation you choose which one?
- fetch = FetchType.LAZY: Loads related entities only when they are accessed.
- fetch = FetchType.EAGER?: Loads related entities immediately when the parent entity is fetched.
- Difference:
- - Core difference: LAZY loads related data only when it is accessed. EAGER loads related data immediately when the entity is fetched.
- Choose LAZY when:
- - Collection is large; Data is not always needed; Performance matters (most real apps)
- Choose EAGER when:
- - Related data is always needed; Relationship is small; Simple demo / learning project
### 9. What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?
- JPA (Spring Data JPA) naming convention refers to derived query methods, where Spring automatically generates SQL based on repository method names.
- The method name must follow this pattern: findBy + EntityFieldName + Keyword
- No, we do NOT implement the method ourselves. Because Spring Data JPA uses dynamic proxy and reflection to generate the implementation at runtime.
- Examples:
- - User findByUsername(String username);
- - User findByEmailAndStatus(String email, String status);
- - List<User> findByRoleOrStatus(String role, String status);
- - List<Order> findByPriceGreaterThan(Double price);
- - List<User> findByNameContaining(String keyword);
- - List<Order> findByCreatedAtBetween(LocalDate start, LocalDate end);
- - List<User> findByIdIn(List<Long> ids);
- - List<User> findByStatusOrderByCreatedAtDesc(String status);
- - List<User> findByDeletedAtIsNull();
- - long countByStatus(String status);
### 10. Try to use JPA advanced methods in your class project. In the repository layer, you need to use the naming convention to use the method provided by JPA.