3.How to create a new thread (Please also consider Thread Pool approach)?
-Extends Thread Class
-Implements Runnable interface
-Implements Callable with Future
-Thread Pool (reduces thread creation overhead and improves performance.)

4.Difference between Runnable and Callable?
-Runnable: cannot return value; cannot throw exception; method is run(); used with Thread
-Callable: can return value; can throw exception; method is call(); used with ExecutorService

5.What is the difference between t.start() and t.run()?
-t.strart(): Creates a new thread and executes run()
-t.run(): Executes in the current thread like a normal method

6.Which way of creating threads is better: Thread class or Runnable interface?
-Runnable is better.
-Reason: 1)Supports multiple inheritance 2)Separates task from thread 3)Works naturally with thread pools

7.What are the thread statuses?
-NEW: Thread created but not started
-RUNNABLE: Running or ready to run
-BLOCKED: Waiting for a monitor lock
-WAITING: Waiting indefinitely (wait(), join())
-TIMED_WAITING: Waiting with timeout (sleep())
-TERMINATED: Thread finished execution

8.Demonstrate deadlock and how to resolve it in Java code.
```java
Object lock1 = new Object();
Object lock2 = new Object();

Thread t1 = new Thread(() -> {
    synchronized (lock1) {
        synchronized (lock2) {
            System.out.println("Thread 1");
        }
    }
});

Thread t2 = new Thread(() -> {
    synchronized (lock2) {
        synchronized (lock1) {
            System.out.println("Thread 2");
        }
    }
});

t1.start();
t2.start();
```
-How to resolve: Always acquire locks in the same order.
```java
synchronized (lock1) {
    synchronized (lock2) {
        // safe
    }
}
```

9.How do threads communicate with each other?
- Using wait(), notify(), notifyAll()


10.Whatâ€™s the difference between class lock and object lock?
-Class Lock: Class-level (synchronized(ClassName.class))
-Object Lock: Instance (synchronized(this))