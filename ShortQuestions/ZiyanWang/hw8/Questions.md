## Part1 - Hands-on Practice
### 0. Environment Setup
- OS: macOS (Apple Silicon / M1)
- IDE: IntelliJ IDEA
- Database: MySQL Community Server 8.0.44
- Build Tool: Maven
- API Test Tool: Postman
### 1.Project Setup
- Cloned the redbook repository
- Switched to branch 02_POST_RUD
- Imported the project into IntelliJ IDEA as a Maven Project
- Ensured all dependencies were successfully downloaded and resolved
### 2.Database Setup
- Installed and started MySQL locally
- Logged into MySQL using root user
- Created a local database named redbook
- Created a new database user for the application
- Verified that the database was accessible from the local machine
### 3.Application Configuration
- Modified src/main/resources/application.properties to match the local MySQL configuration
- ![Maven Clean and Compile](Maven%20Clean%20and%20Compile.jpeg)
### 4.Build with Maven
- Executed Maven build to ensure the project compiled successfully:
- - mvn clean
- - mvn compile
- Build completed successfully without errors.
- ![Run Application](Run%20app.jpeg)
### 5. Run Spring Boot Application
- Started the application by running RedbookApplication
- Resolved port conflict on 8080 by stopping the existing Apache process
- Verified application startup logs showed:
- - Tomcat started on port(s): 8080 
- - Started RedbookApplication
- ![Postman Request](Postman%20Request.jpeg)
### 6. API Testing with Postman
- Create a Post (POST)
- Endpoint: POST http://localhost:8080/api/v1/posts
- Headers: Content-Type: application/json
- This confirmed the Spring Boot application was running successfully.

---
## Part2 - Questions:
1. Did you create the table POSTS in the database? 
if not, who did it for you? Can I change this behavior? (Hint: look at the application.properties file)
- No, I did not manually create the POSTS table in the database.
- The table was automatically created by Hibernate (JPA provider) when the Spring Boot application started.
- - Hibernate inspects the Entity classes in the project (e.g. @Entity Post) and generates the corresponding database tables based on the entity fields.
- - This behavior is controlled by the following configuration in application.properties: spring.jpa.hibernate.ddl-auto=update
- - With ddl-auto=update, Hibernate will:
- - - Automatically create tables if they do not exist
- - - Update table schema when entity structure changes
- - - Preserve existing data
- Can I change this behavior? Yes.
- - create → drop and recreate tables every time (data lost)
- - create-drop → create on startup, drop on shutdown
- - validate → only validate schema, do not modify DB
- - none → completely disable schema management
2. Is your id in the database same as what you set in your request? why does this happen? 
(Hint: search the annotations used in your code)
- No, the id stored in the database is not the same as any value set in the request body.
- This happens because the id field is automatically generated by the database, not provided by the client.
- In the entity class, the id field uses the following annotations:
```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```
- - Because of @GeneratedValue(strategy = GenerationType.IDENTITY):
- - The database is responsible for generating the primary key
- - he client must not control or set the id
- - MySQL automatically assigns an auto-increment value when a record is inserted
- As a result:
- - Any id value sent in the request body is ignored
- - The actual id comes from the database and is returned in the response
- This design ensures:
- - Data integrity
- - No primary key conflicts
- - Proper separation between client input and database identity management